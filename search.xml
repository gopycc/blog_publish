<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git cheat sheet 让你不用再去记所有的git命令</title>
      <link href="/2018/git-cheat-sheet/"/>
      <url>/2018/git-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<p>在 <a href="http://goinon.org/2018/git-talk/">分享一点Git的感受与总结</a>讲到了vscode中使用git命令行的便利，同时有人在github上分享了一份git的命令手册，转过来备查，愿你也能了然于心。</p><p>github: <a href="https://github.com/arslanbilal/git-cheat-sheet" target="_blank" rel="noopener">https://github.com/arslanbilal/git-cheat-sheet</a></p><p>下面开始Git Cheat Sheet的内容</p><hr><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li><a href="#配置">配置</a></li><li><a href="#配置文件">配置文件</a></li><li><a href="#创建">创建</a></li><li><a href="#本地修改">本地修改</a></li><li><a href="#搜索">搜索</a></li><li><a href="#提交历史">提交历史</a></li><li><a href="#分支与标签">分支与标签</a></li><li><a href="#更新与发布">更新与发布</a></li><li><a href="#合并与重置">合并与重置</a></li><li><a href="#撤销">撤销</a></li><li><a href="#git-flow">Git Flow</a></li></ul><hr><a id="more"></a><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="列出当前配置："><a href="#列出当前配置：" class="headerlink" title="列出当前配置："></a>列出当前配置：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure><h4 id="列出repository配置："><a href="#列出repository配置：" class="headerlink" title="列出repository配置："></a>列出repository配置：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --local --list</span><br></pre></td></tr></table></figure><h4 id="列出全局配置："><a href="#列出全局配置：" class="headerlink" title="列出全局配置："></a>列出全局配置：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global --list</span><br></pre></td></tr></table></figure><h4 id="列出系统配置："><a href="#列出系统配置：" class="headerlink" title="列出系统配置："></a>列出系统配置：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --system --list</span><br></pre></td></tr></table></figure><h4 id="设置用户名："><a href="#设置用户名：" class="headerlink" title="设置用户名："></a>设置用户名：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name “[firstname lastname]”</span><br></pre></td></tr></table></figure><h4 id="设置用户邮箱："><a href="#设置用户邮箱：" class="headerlink" title="设置用户邮箱："></a>设置用户邮箱：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.email “[valid-email]”</span><br></pre></td></tr></table></figure><h4 id="设置git命令输出为彩色："><a href="#设置git命令输出为彩色：" class="headerlink" title="设置git命令输出为彩色："></a>设置git命令输出为彩色：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global color.ui auto</span><br></pre></td></tr></table></figure><h4 id="设置git使用的文本编辑器设："><a href="#设置git使用的文本编辑器设：" class="headerlink" title="设置git使用的文本编辑器设："></a>设置git使用的文本编辑器设：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global core.editor vi</span><br></pre></td></tr></table></figure><hr><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="Repository配置对应的配置文件路径-–local-："><a href="#Repository配置对应的配置文件路径-–local-：" class="headerlink" title="Repository配置对应的配置文件路径[–local]："></a>Repository配置对应的配置文件路径[–local]：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;repo&gt;/.git/config</span><br></pre></td></tr></table></figure><h4 id="用户全局配置对应的配置文件路径-–global-："><a href="#用户全局配置对应的配置文件路径-–global-：" class="headerlink" title="用户全局配置对应的配置文件路径[–global]："></a>用户全局配置对应的配置文件路径[–global]：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.gitconfig</span><br></pre></td></tr></table></figure><h4 id="系统配置对应的配置文件路径-–local-："><a href="#系统配置对应的配置文件路径-–local-：" class="headerlink" title="系统配置对应的配置文件路径[–local]："></a>系统配置对应的配置文件路径[–local]：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/gitconfig</span><br></pre></td></tr></table></figure><hr><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="复制一个已创建的仓库"><a href="#复制一个已创建的仓库" class="headerlink" title="复制一个已创建的仓库:"></a>复制一个已创建的仓库:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 SSH</span></span><br><span class="line">$ git <span class="built_in">clone</span> ssh://user@domain.com/repo.git</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过 HTTP</span></span><br><span class="line">$ git <span class="built_in">clone</span> http://domain.com/user/repo.git</span><br></pre></td></tr></table></figure><h4 id="创建一个新的本地仓库"><a href="#创建一个新的本地仓库" class="headerlink" title="创建一个新的本地仓库:"></a>创建一个新的本地仓库:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><hr><h3 id="本地修改"><a href="#本地修改" class="headerlink" title="本地修改"></a>本地修改</h3><h4 id="显示工作路径下已修改的文件："><a href="#显示工作路径下已修改的文件：" class="headerlink" title="显示工作路径下已修改的文件："></a>显示工作路径下已修改的文件：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><h4 id="显示与上次提交版本文件的不同："><a href="#显示与上次提交版本文件的不同：" class="headerlink" title="显示与上次提交版本文件的不同："></a>显示与上次提交版本文件的不同：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br></pre></td></tr></table></figure><h4 id="把当前所有修改添加到下次提交中："><a href="#把当前所有修改添加到下次提交中：" class="headerlink" title="把当前所有修改添加到下次提交中："></a>把当前所有修改添加到下次提交中：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure><h4 id="把对某个文件的修改添加到下次提交中："><a href="#把对某个文件的修改添加到下次提交中：" class="headerlink" title="把对某个文件的修改添加到下次提交中："></a>把对某个文件的修改添加到下次提交中：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add -p &lt;file&gt;</span><br></pre></td></tr></table></figure><h4 id="提交本地的所有修改："><a href="#提交本地的所有修改：" class="headerlink" title="提交本地的所有修改："></a>提交本地的所有修改：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -a</span><br></pre></td></tr></table></figure><h4 id="提交之前已标记的变化："><a href="#提交之前已标记的变化：" class="headerlink" title="提交之前已标记的变化："></a>提交之前已标记的变化：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></table></figure><h4 id="附加消息提交："><a href="#附加消息提交：" class="headerlink" title="附加消息提交："></a>附加消息提交：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;message here&apos;</span><br></pre></td></tr></table></figure><h4 id="提交，并将提交时间设置为之前的某个日期"><a href="#提交，并将提交时间设置为之前的某个日期" class="headerlink" title="提交，并将提交时间设置为之前的某个日期:"></a>提交，并将提交时间设置为之前的某个日期:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --date=&quot;`date --date=&apos;n day ago&apos;`&quot; -am &quot;Commit Message&quot;</span><br></pre></td></tr></table></figure><h4 id="修改上次提交"><a href="#修改上次提交" class="headerlink" title="修改上次提交"></a>修改上次提交</h4><p><em><sub>请勿修改已发布的提交记录!</sub></em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure></p><h4 id="修改上次提交的committer-date："><a href="#修改上次提交的committer-date：" class="headerlink" title="修改上次提交的committer date："></a>修改上次提交的committer date：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GIT_COMMITTER_DATE=&quot;date&quot; git commit --amend</span><br></pre></td></tr></table></figure><h4 id="修改上次提交的author-date："><a href="#修改上次提交的author-date：" class="headerlink" title="修改上次提交的author date："></a>修改上次提交的author date：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend --date=&quot;date&quot;</span><br></pre></td></tr></table></figure><h4 id="把当前分支中未提交的修改移动到其他分支："><a href="#把当前分支中未提交的修改移动到其他分支：" class="headerlink" title="把当前分支中未提交的修改移动到其他分支："></a>把当前分支中未提交的修改移动到其他分支：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git checkout branch2</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><h4 id="将-stashed-changes-应用到当前分支："><a href="#将-stashed-changes-应用到当前分支：" class="headerlink" title="将 stashed changes 应用到当前分支："></a>将 stashed changes 应用到当前分支：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure><h4 id="删除最新一次的-stashed-changes："><a href="#删除最新一次的-stashed-changes：" class="headerlink" title="删除最新一次的 stashed changes："></a>删除最新一次的 stashed changes：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash drop</span><br></pre></td></tr></table></figure><hr><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><h4 id="从当前目录的所有文件中查找文本内容："><a href="#从当前目录的所有文件中查找文本内容：" class="headerlink" title="从当前目录的所有文件中查找文本内容："></a>从当前目录的所有文件中查找文本内容：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git grep &quot;Hello&quot;</span><br></pre></td></tr></table></figure><h4 id="在某一版本中搜索文本："><a href="#在某一版本中搜索文本：" class="headerlink" title="在某一版本中搜索文本："></a>在某一版本中搜索文本：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git grep &quot;Hello&quot; v2.5</span><br></pre></td></tr></table></figure><hr><h3 id="提交历史"><a href="#提交历史" class="headerlink" title="提交历史"></a>提交历史</h3><h4 id="从最新提交开始，显示所有的提交记录（显示hash，-作者信息，提交的标题和时间）："><a href="#从最新提交开始，显示所有的提交记录（显示hash，-作者信息，提交的标题和时间）：" class="headerlink" title="从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）："></a>从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br></pre></td></tr></table></figure><h4 id="显示所有提交（仅显示提交的hash和message）："><a href="#显示所有提交（仅显示提交的hash和message）：" class="headerlink" title="显示所有提交（仅显示提交的hash和message）："></a>显示所有提交（仅显示提交的hash和message）：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline</span><br></pre></td></tr></table></figure><h4 id="显示某个用户的所有提交："><a href="#显示某个用户的所有提交：" class="headerlink" title="显示某个用户的所有提交："></a>显示某个用户的所有提交：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --author=&quot;username&quot;</span><br></pre></td></tr></table></figure><h4 id="显示某个文件的所有修改："><a href="#显示某个文件的所有修改：" class="headerlink" title="显示某个文件的所有修改："></a>显示某个文件的所有修改：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log -p &lt;file&gt;</span><br></pre></td></tr></table></figure><h4 id="仅显示远端-lt-remote-master-gt-分支与远端-lt-origin-master-gt-分支提交记录的差集："><a href="#仅显示远端-lt-remote-master-gt-分支与远端-lt-origin-master-gt-分支提交记录的差集：" class="headerlink" title="仅显示远端&lt;remote/master&gt;分支与远端&lt;origin/master&gt;分支提交记录的差集："></a>仅显示远端&lt;remote/master&gt;分支与远端&lt;origin/master&gt;分支提交记录的差集：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline &lt;origin/master&gt;..&lt;remote/master&gt; --left-right</span><br></pre></td></tr></table></figure><h4 id="谁，在什么时间，修改了文件的什么内容："><a href="#谁，在什么时间，修改了文件的什么内容：" class="headerlink" title="谁，在什么时间，修改了文件的什么内容："></a>谁，在什么时间，修改了文件的什么内容：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;file&gt;</span><br></pre></td></tr></table></figure><h4 id="显示reflog："><a href="#显示reflog：" class="headerlink" title="显示reflog："></a>显示reflog：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog show</span><br></pre></td></tr></table></figure><h4 id="删除reflog："><a href="#删除reflog：" class="headerlink" title="删除reflog："></a>删除reflog：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog delete</span><br></pre></td></tr></table></figure><hr><h3 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h3><h4 id="列出所有的分支："><a href="#列出所有的分支：" class="headerlink" title="列出所有的分支："></a>列出所有的分支：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></table></figure><h4 id="列出所有的远端分支："><a href="#列出所有的远端分支：" class="headerlink" title="列出所有的远端分支："></a>列出所有的远端分支：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -r</span><br></pre></td></tr></table></figure><h4 id="切换分支："><a href="#切换分支：" class="headerlink" title="切换分支："></a>切换分支：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout &lt;branch&gt;</span><br></pre></td></tr></table></figure><h4 id="创建并切换到新分支"><a href="#创建并切换到新分支" class="headerlink" title="创建并切换到新分支:"></a>创建并切换到新分支:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b &lt;branch&gt;</span><br></pre></td></tr></table></figure><h4 id="基于当前分支创建新分支："><a href="#基于当前分支创建新分支：" class="headerlink" title="基于当前分支创建新分支："></a>基于当前分支创建新分支：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch &lt;new-branch&gt;</span><br></pre></td></tr></table></figure><h4 id="基于远程分支创建新的可追溯的分支："><a href="#基于远程分支创建新的可追溯的分支：" class="headerlink" title="基于远程分支创建新的可追溯的分支："></a>基于远程分支创建新的可追溯的分支：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --track &lt;new-branch&gt; &lt;remote-branch&gt;</span><br></pre></td></tr></table></figure><h4 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支:"></a>删除本地分支:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d &lt;branch&gt;</span><br></pre></td></tr></table></figure><h4 id="强制删除一个本地分支："><a href="#强制删除一个本地分支：" class="headerlink" title="强制删除一个本地分支："></a>强制删除一个本地分支：<br></h4><p><em><sub>将会丢失未合并的修改！</sub></em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D &lt;branch&gt;</span><br></pre></td></tr></table></figure><h4 id="给当前版本打标签："><a href="#给当前版本打标签：" class="headerlink" title="给当前版本打标签："></a>给当前版本打标签：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag &lt;tag-name&gt;</span><br></pre></td></tr></table></figure><h4 id="给当前版本打标签并附加消息："><a href="#给当前版本打标签并附加消息：" class="headerlink" title="给当前版本打标签并附加消息："></a>给当前版本打标签并附加消息：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a &lt;tag-name&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="更新与发布"><a href="#更新与发布" class="headerlink" title="更新与发布"></a>更新与发布</h3><h4 id="列出当前配置的远程端："><a href="#列出当前配置的远程端：" class="headerlink" title="列出当前配置的远程端："></a>列出当前配置的远程端：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure><h4 id="显示远程端的信息："><a href="#显示远程端的信息：" class="headerlink" title="显示远程端的信息："></a>显示远程端的信息：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show &lt;remote&gt;</span><br></pre></td></tr></table></figure><h4 id="添加新的远程端："><a href="#添加新的远程端：" class="headerlink" title="添加新的远程端："></a>添加新的远程端：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add &lt;remote&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure><h4 id="下载远程端版本，但不合并到HEAD中："><a href="#下载远程端版本，但不合并到HEAD中：" class="headerlink" title="下载远程端版本，但不合并到HEAD中："></a>下载远程端版本，但不合并到HEAD中：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch &lt;remote&gt;</span><br></pre></td></tr></table></figure><h4 id="下载远程端版本，并自动与HEAD版本合并："><a href="#下载远程端版本，并自动与HEAD版本合并：" class="headerlink" title="下载远程端版本，并自动与HEAD版本合并："></a>下载远程端版本，并自动与HEAD版本合并：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote pull &lt;remote&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure><h4 id="将远程端版本合并到本地版本中："><a href="#将远程端版本合并到本地版本中：" class="headerlink" title="将远程端版本合并到本地版本中："></a>将远程端版本合并到本地版本中：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master</span><br></pre></td></tr></table></figure><h4 id="以rebase方式将远端分支与本地合并："><a href="#以rebase方式将远端分支与本地合并：" class="headerlink" title="以rebase方式将远端分支与本地合并："></a>以rebase方式将远端分支与本地合并：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure><h4 id="将本地版本发布到远程端："><a href="#将本地版本发布到远程端：" class="headerlink" title="将本地版本发布到远程端："></a>将本地版本发布到远程端：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push remote &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure><h4 id="删除远程端分支："><a href="#删除远程端分支：" class="headerlink" title="删除远程端分支："></a>删除远程端分支：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push &lt;remote&gt; :&lt;branch&gt; (since Git v1.5.0)</span><br><span class="line">or</span><br><span class="line">git push &lt;remote&gt; --delete &lt;branch&gt; (since Git v1.7.0)</span><br></pre></td></tr></table></figure><h4 id="发布标签"><a href="#发布标签" class="headerlink" title="发布标签:"></a>发布标签:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push --tags</span><br></pre></td></tr></table></figure><hr><h3 id="合并与重置-Rebase"><a href="#合并与重置-Rebase" class="headerlink" title="合并与重置(Rebase)"></a>合并与重置(Rebase)</h3><h4 id="将分支合并到当前HEAD中："><a href="#将分支合并到当前HEAD中：" class="headerlink" title="将分支合并到当前HEAD中："></a>将分支合并到当前HEAD中：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure><h4 id="将当前HEAD版本重置到分支中"><a href="#将当前HEAD版本重置到分支中" class="headerlink" title="将当前HEAD版本重置到分支中:"></a>将当前HEAD版本重置到分支中:</h4><p><em><sub>请勿重置已发布的提交!</sub></em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase &lt;branch&gt;</span><br></pre></td></tr></table></figure></p><h4 id="退出重置"><a href="#退出重置" class="headerlink" title="退出重置:"></a>退出重置:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --abort</span><br></pre></td></tr></table></figure><h4 id="解决冲突后继续重置："><a href="#解决冲突后继续重置：" class="headerlink" title="解决冲突后继续重置："></a>解决冲突后继续重置：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --continue</span><br></pre></td></tr></table></figure><h4 id="使用配置好的merge-tool-解决冲突："><a href="#使用配置好的merge-tool-解决冲突：" class="headerlink" title="使用配置好的merge tool 解决冲突："></a>使用配置好的merge tool 解决冲突：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mergetool</span><br></pre></td></tr></table></figure><h4 id="在编辑器中手动解决冲突后，标记文件为已解决冲突："><a href="#在编辑器中手动解决冲突后，标记文件为已解决冲突：" class="headerlink" title="在编辑器中手动解决冲突后，标记文件为已解决冲突："></a>在编辑器中手动解决冲突后，标记文件为<code>已解决冲突</code>：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add &lt;resolved-file&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm &lt;resolved-file&gt;</span><br></pre></td></tr></table></figure><h4 id="合并提交："><a href="#合并提交：" class="headerlink" title="合并提交："></a>合并提交：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i &lt;commit-just-before-first&gt;</span><br></pre></td></tr></table></figure><p>把上面的内容替换为下面的内容：</p><p>原内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick &lt;commit_id&gt;</span><br><span class="line">pick &lt;commit_id2&gt;</span><br><span class="line">pick &lt;commit_id3&gt;</span><br></pre></td></tr></table></figure></p><p>替换为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick &lt;commit_id&gt;</span><br><span class="line">squash &lt;commit_id2&gt;</span><br><span class="line">squash &lt;commit_id3&gt;</span><br></pre></td></tr></table></figure></p><hr><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><h4 id="放弃工作目录下的所有修改："><a href="#放弃工作目录下的所有修改：" class="headerlink" title="放弃工作目录下的所有修改："></a>放弃工作目录下的所有修改：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD</span><br></pre></td></tr></table></figure><h4 id="移除缓存区的所有文件（i-e-撤销上次git-add）"><a href="#移除缓存区的所有文件（i-e-撤销上次git-add）" class="headerlink" title="移除缓存区的所有文件（i.e. 撤销上次git add）:"></a>移除缓存区的所有文件（i.e. 撤销上次<code>git add</code>）:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD</span><br></pre></td></tr></table></figure><h4 id="放弃某个文件的所有本地修改："><a href="#放弃某个文件的所有本地修改：" class="headerlink" title="放弃某个文件的所有本地修改："></a>放弃某个文件的所有本地修改：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure><h4 id="重置一个提交（通过创建一个截然不同的新提交）"><a href="#重置一个提交（通过创建一个截然不同的新提交）" class="headerlink" title="重置一个提交（通过创建一个截然不同的新提交）"></a>重置一个提交（通过创建一个截然不同的新提交）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git revert &lt;commit&gt;</span><br></pre></td></tr></table></figure><h4 id="将HEAD重置到指定的版本，并抛弃该版本之后的所有修改："><a href="#将HEAD重置到指定的版本，并抛弃该版本之后的所有修改：" class="headerlink" title="将HEAD重置到指定的版本，并抛弃该版本之后的所有修改："></a>将HEAD重置到指定的版本，并抛弃该版本之后的所有修改：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard &lt;commit&gt;</span><br></pre></td></tr></table></figure><h4 id="用远端分支强制覆盖本地分支："><a href="#用远端分支强制覆盖本地分支：" class="headerlink" title="用远端分支强制覆盖本地分支："></a>用远端分支强制覆盖本地分支：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;remote/branch&gt; e.g., upstream/master, origin/my-feature</span><br></pre></td></tr></table></figure><h4 id="将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改："><a href="#将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改：" class="headerlink" title="将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改："></a>将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset &lt;commit&gt;</span><br></pre></td></tr></table></figure><h4 id="将HEAD重置到上一次提交的版本，并保留未提交的本地修改："><a href="#将HEAD重置到上一次提交的版本，并保留未提交的本地修改：" class="headerlink" title="将HEAD重置到上一次提交的版本，并保留未提交的本地修改："></a>将HEAD重置到上一次提交的版本，并保留未提交的本地修改：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --keep &lt;commit&gt;</span><br></pre></td></tr></table></figure><h4 id="删除添加-gitignore文件前错误提交的文件："><a href="#删除添加-gitignore文件前错误提交的文件：" class="headerlink" title="删除添加.gitignore文件前错误提交的文件："></a>删除添加<code>.gitignore</code>文件前错误提交的文件：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git rm -r --cached .</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;remove xyz file&quot;</span><br></pre></td></tr></table></figure><hr><h2 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git-Flow"></a>Git-Flow</h2><h3 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h3><ul><li><a href="#安装">安装</a></li><li><a href="#开始">开始</a></li><li><a href="#特性">特性</a></li><li><a href="#做一个release版本">做一个release版本</a></li><li><a href="#紧急修复">紧急修复</a></li><li><a href="#commands">Commands</a></li></ul><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>你需要有一个可以工作的 git 作为前提。</li><li>Git flow 可以工作在 OSX, Linux 和 Windows之下</li></ul><h4 id="OSX-Homebrew"><a href="#OSX-Homebrew" class="headerlink" title="OSX Homebrew:"></a>OSX Homebrew:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install git-flow</span><br></pre></td></tr></table></figure><h4 id="OSX-Macports"><a href="#OSX-Macports" class="headerlink" title="OSX Macports:"></a>OSX Macports:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port install git-flow</span><br></pre></td></tr></table></figure><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux:"></a>Linux:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install git-flow</span><br></pre></td></tr></table></figure><h4 id="Windows-Cygwin"><a href="#Windows-Cygwin" class="headerlink" title="Windows (Cygwin):"></a>Windows (Cygwin):</h4><p>安装 git-flow, 你需要 wget 和 util-linux。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -q -O - --no-check-certificate https://github.com/nvie/gitflow/raw/develop/contrib/gitflow-installer.sh | bash</span><br></pre></td></tr></table></figure><hr><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ul><li>为了自定义你的项目，Git flow 需要初始化过程。</li><li>使用 git-flow，从初始化一个现有的 git 库内开始。</li><li>初始化，你必须回答几个关于分支的命名约定的问题。建议使用默认值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow init</span><br></pre></td></tr></table></figure><hr><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>为即将发布的版本开发新功能特性。</li><li>这通常只存在开发者的库中。</li></ul><h4 id="创建一个新特性"><a href="#创建一个新特性" class="headerlink" title="创建一个新特性:"></a>创建一个新特性:</h4><p>下面操作创建了一个新的feature分支，并切换到该分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow feature start MYFEATURE</span><br></pre></td></tr></table></figure><h4 id="完成新特性的开发"><a href="#完成新特性的开发" class="headerlink" title="完成新特性的开发:"></a>完成新特性的开发:</h4><p>完成开发新特性。这个动作执行下面的操作：</p><ol><li>合并 MYFEATURE 分支到 ‘develop’</li><li>删除这个新特性分支</li><li>切换回 ‘develop’ 分支</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow feature finish MYFEATURE</span><br></pre></td></tr></table></figure><h4 id="发布新特性"><a href="#发布新特性" class="headerlink" title="发布新特性:"></a>发布新特性:</h4><p>你是否合作开发一项新特性？<br>发布新特性分支到远程服务器，所以，其它用户也可以使用这分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow feature publish MYFEATURE</span><br></pre></td></tr></table></figure><h4 id="取得一个发布的新特性分支"><a href="#取得一个发布的新特性分支" class="headerlink" title="取得一个发布的新特性分支:"></a>取得一个发布的新特性分支:</h4><p>取得其它用户发布的新特性分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow feature pull origin MYFEATURE</span><br></pre></td></tr></table></figure><h4 id="追溯远端上的特性"><a href="#追溯远端上的特性" class="headerlink" title="追溯远端上的特性:"></a>追溯远端上的特性:</h4><p>通过下面命令追溯远端上的特性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow feature track MYFEATURE</span><br></pre></td></tr></table></figure><hr><h3 id="做一个release版本"><a href="#做一个release版本" class="headerlink" title="做一个release版本"></a>做一个release版本</h3><ul><li>支持一个新的用于生产环境的发布版本。</li><li>允许修正小问题，并为发布版本准备元数据。</li></ul><h4 id="开始创建release版本"><a href="#开始创建release版本" class="headerlink" title="开始创建release版本:"></a>开始创建release版本:</h4><ul><li>开始创建release版本，使用 git flow release 命令。 </li><li>‘release’ 分支的创建基于 ‘develop’ 分支。 </li><li>你可以选择提供一个 [BASE]参数，即提交记录的 sha-1 hash 值，来开启动 release 分支。</li><li>这个提交记录的 sha-1 hash 值必须是’develop’ 分支下的。 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow release start RELEASE [BASE]</span><br></pre></td></tr></table></figure><p>创建 release 分支之后立即发布允许其它用户向这个 release 分支提交内容是个明智的做法。命令十分类似发布新特性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow release publish RELEASE</span><br></pre></td></tr></table></figure><p>(你可以通过<br><code>git flow release track RELEASE</code> 命令追溯远端的 release 版本)</p><h4 id="完成-release-版本"><a href="#完成-release-版本" class="headerlink" title="完成 release 版本:"></a>完成 release 版本:</h4><p>完成 release 版本是一个大 git 分支操作。它执行下面几个动作：</p><ol><li>归并 release 分支到 ‘master’ 分支。</li><li>用 release 分支名打 Tag</li><li>归并 release 分支到 ‘develop’</li><li>移除 release 分支。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow release finish RELEASE</span><br></pre></td></tr></table></figure><p>不要忘记使用<code>git push --tags</code>将tags推送到远端</p><hr><h3 id="紧急修复"><a href="#紧急修复" class="headerlink" title="紧急修复"></a>紧急修复</h3><p>紧急修复来自这样的需求：生产环境的版本处于一个不预期状态，需要立即修正。有可能是需要修正 master 分支上某个 TAG 标记的生产版本。</p><h4 id="开始-git-flow-紧急修复"><a href="#开始-git-flow-紧急修复" class="headerlink" title="开始 git flow 紧急修复:"></a>开始 git flow 紧急修复:</h4><p>像其它 git flow 命令一样, 紧急修复分支开始自：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git flow hotfix start VERSION [BASENAME]</span><br></pre></td></tr></table></figure><p>VERSION 参数标记着修正版本。你可以从 <code>[BASENAME]开始，</code>[BASENAME]`为finish release时填写的版本号</p><h4 id="完成紧急修复"><a href="#完成紧急修复" class="headerlink" title="完成紧急修复:"></a>完成紧急修复:</h4><p>当完成紧急修复分支，代码归并回 develop 和 master 分支。相应地，master 分支打上修正版本的 TAG。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow hotfix finish VERSION</span><br></pre></td></tr></table></figure><hr><h3 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h3><p></p><p align="center"><br>    <img alt="Git" src="/images/git-flow-commands.png" height="270" width="460"><br></p><p></p><hr><h3 id="Git-flow-schema"><a href="#Git-flow-schema" class="headerlink" title="Git flow schema"></a>Git flow schema</h3><p></p><p align="center"><br>    <img alt="Git" src="/images/git-flow-commands-without-flow.png"><br></p><p></p><hr>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> git-flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享一点Git的感受与总结</title>
      <link href="/2018/git-talk/"/>
      <url>/2018/git-talk/</url>
      
        <content type="html"><![CDATA[<h3 id="GIT入门法宝-客户端"><a href="#GIT入门法宝-客户端" class="headerlink" title="GIT入门法宝-客户端"></a>GIT入门法宝-客户端</h3><p>刚开始接触GIT有一个好用的图形客户端非常重要，比如神器Sourcetree，不但界面简单大气而且非常稳定，配合kdiff3复杂的分支操作一点也不虚，而且支持git-flow。但它的缺点就是反应有点慢，TP460P也只能勉强是不卡，算不上流畅。后来用过一个章鱼客户端GitKraken界面做的很漂亮，同时也没有影响它的操作流畅度，只是软件比较新，功能相对sourcetree要弱一些，简单的提交拉取用一下，没有作为主力客户端，特别是像在的功能分支合并冲突时或排查问题时还要走sourcetree。</p><h3 id="前后端开发神器的出现"><a href="#前后端开发神器的出现" class="headerlink" title="前后端开发神器的出现"></a>前后端开发神器的出现</h3><p>直到微软推出了一个前后端通吃的编码神器vscode后，GIT命令行才占据了主流场景，一行命令搞定的事情也就没必要切换到客户端，结合GIT插件合并冲突也一并在vscode中解决了，然后再写个node脚本一句node msbuild直接把编译的事情也做了，再通过iisexpress就可以直接无障碍运行，效率大大的高，vs都很少打开了。</p><h3 id="GIT的简单与复杂"><a href="#GIT的简单与复杂" class="headerlink" title="GIT的简单与复杂"></a>GIT的简单与复杂</h3><p>要想把git用的行云流水，不管网上看了多少资料，最后一定要把git-scm的文档从头到尾来回多看几遍，因为你会发现众里她千百度，答案就在git-scm上。只有git的理念和底层原理清楚了，遇到问题的时候才能胸有成竹。特别是刚开始在公司里推行git，很多开发人员在同一个仓库里工作的时候，问题一定会有的。git另开发人员更加自由，但也不容易为普通开发人员驾驭，在他们还没有体会到git的好处时一定会有很多抱怨，时常会带着操作svn的思维与svn做对比，就像一直在用单体结构开发的时候去看分布式系统一样。</p><p>这时要做的就是强制大家先用起来，加以约束与引导，时间会让所有人成长。</p><p>本文末尾会有一个git的命令手册和git-scm文档地址。</p><h3 id="Git-flow分支管理的向导"><a href="#Git-flow分支管理的向导" class="headerlink" title="Git-flow分支管理的向导"></a>Git-flow分支管理的向导</h3><p>git-flow是一套很完备的git分支管理方案，从功能开发到发布，到遇到问题后的补丁修改，有一套成熟的流程指导。我们的分支管理基于git-flow做了简化，因为所有人都是从svn转到git上开发，git-flow的流程太长，很多开发人员包括管理人员都不太能接受，很容易从入门到放弃。另一个原因是产品的灰度发布周期比较长，不算特殊版本的情况下至少有3个常驻版本并行，hotfix分支和release分支的生命周期相对git-flow要长的多，这一点比较类似于github的stable分支方式。</p><h3 id="golang乱入"><a href="#golang乱入" class="headerlink" title="golang乱入"></a>golang乱入</h3><p>git也是后来让我喜欢golang的原因：简单。简单不是单纯指语法简单容易学习云云…精通一门语言从来不是一件简单的事，除了语法本身还要了解库、模式、工具与周边的生态，但go让你写起代码很流畅，写完之后跑起来也很清爽，没有束缚，可以跨平台，可以docker，也不需要额外装运行时。</p><hr><ul><li><a href="http://goinon.org/2018/git-cheat-sheet/">Git-Cheat-Sheet</a></li><li><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git-Scm</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> git-flow </tag>
            
            <tag> vscode </tag>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang统一处理HTTP请求中的异常捕获</title>
      <link href="/2017/golang-wraphandle/"/>
      <url>/2017/golang-wraphandle/</url>
      
        <content type="html"><![CDATA[<p><em>对所有注册的路由handle进行异常捕获</em></p><p>golang使用panic()产生异常，然后可以recover()来捕获到异常，否则主程序直接宕掉，这是我们不希望看到的。<br>或者全程检查error，不主动抛出异常。即便这样，可能异常依然不能避免。</p><p>现在即要recover()，又不用在每个handle里面都去recover()一遍。</p><a id="more"></a><p><em>从普通的路由注册代码开始</em></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegRouters</span><span class="params">(r *httprouter.Router)</span></span> &#123;</span><br><span class="line">r.GET(<span class="string">"/"</span>, Home)</span><br><span class="line">r.GET(<span class="string">"/contact"</span>, Contact)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Home</span><span class="params">(w http.ResponseWriter, r *http.Request, params httprouter.Params)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> pr := <span class="built_in">recover</span>(); pr != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"panic recover: %v\r\n"</span>, pr)</span><br><span class="line">debug.PrintStack()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">//something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contact</span><span class="params">(w http.ResponseWriter, r *http.Request, params httprouter.Params)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> pr := <span class="built_in">recover</span>(); pr != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"panic recover: %v\r\n"</span>, pr)</span><br><span class="line">debug.PrintStack()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">//something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Wrap方法把处理方法包裹起来。wrap方法需要有一个handle类型的参数，同时返回值要能被httprouter接收<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegRouters</span><span class="params">(r *httprouter.Router)</span></span> &#123;</span><br><span class="line">r.GET(<span class="string">"/"</span>, WrapHandle(Home))</span><br><span class="line">r.GET(<span class="string">"/contact"</span>, WrapHandle(Contact))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WrapHandle</span><span class="params">(handle httprouter.Handle)</span> <span class="title">httprouter</span>.<span class="title">Handle</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request, p httprouter.Params)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> pr := <span class="built_in">recover</span>(); pr != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"panic recover: %v\r\n"</span>, pr)</span><br><span class="line">debug.PrintStack()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">handle(w, r, p)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再把handle简化一下，增加一个context包，将handle的参数包裹起来，当然context还可以进一步处理。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WrapHandle</span><span class="params">(handle <span class="keyword">func</span>(ctx *context.Context)</span>) <span class="title">httprouter</span>.<span class="title">Handle</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request, p httprouter.Params)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> pr := <span class="built_in">recover</span>(); pr != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"panic recover: %v"</span>, pr)</span><br><span class="line">debug.PrintStack()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">ctx := context.NewContext(w, r, p)</span><br><span class="line">handle(ctx)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Home</span><span class="params">(ctx *context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> pr := <span class="built_in">recover</span>(); pr != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"panic recover: %v\r\n"</span>, pr)</span><br><span class="line">debug.PrintStack()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">//something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contact</span><span class="params">(ctx *context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> pr := <span class="built_in">recover</span>(); pr != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"panic recover: %v\r\n"</span>, pr)</span><br><span class="line">debug.PrintStack()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">//something</span></span><br><span class="line">id = ctx.FormInt64(<span class="string">"id"</span>) <span class="comment">//通过context从FORM取值，并转换为int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的请求上下文的原型：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">responseWriter http.ResponseWriter</span><br><span class="line">request        *http.Request</span><br><span class="line">params         httprouter.Params</span><br><span class="line">Data           <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContext</span><span class="params">(w http.ResponseWriter, r *http.Request, params httprouter.Params)</span> *<span class="title">Context</span></span> &#123;</span><br><span class="line">ctx := <span class="built_in">new</span>(Context)</span><br><span class="line">ctx.responseWriter = w</span><br><span class="line">ctx.request = r</span><br><span class="line">ctx.params = params</span><br><span class="line">ctx.Data = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">return</span> ctx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctx *Context)</span> <span class="title">FormValue</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctx.request.FormValue(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctx *Context)</span> <span class="title">FormInt64</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">value, _ := strconv.ParseInt(ctx.FormValue(name), <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> httprouter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10周年更新后程序各种卡死，进程无法结束怎么破？</title>
      <link href="/2016/win10-update-event-129/"/>
      <url>/2016/win10-update-event-129/</url>
      
        <content type="html"><![CDATA[<p>最近THINKPAD T460P更新了WIN10周年版后程序各种卡死，运行一段时间，各种程序就开始崩溃，进程无法结束，最终只能强制关机。</p><p>这个BUG微软已经确认了，安装了SSD+HDD双硬盘的WIN10系统容易中招。</p><p>查看系统日志出现大片的警告：<br>事件ID:129，<br>来源：storahci，<br>常规：发出了对设备 \Device\RaidPort0 的重置。</p><p>故障原因大致是由于WIN10自带的IDE ATA/ATAPI控制器版本太旧，导致存储控制器不兼容，无法识别硬盘。</p><p>解决办法：安装intel最新的英特尔®快速存储技术 (英特尔® RST) RAID 驱动程序。已安装确认可行。</p><p>下载：<a href="https://downloadcenter.intel.com/zh-cn/download/26361/Intel-Rapid-Storage-Technology-Intel-RST-RAID-Driver?v=t" target="_blank" rel="noopener">https://downloadcenter.intel.com/zh-cn/download/26361/Intel-Rapid-Storage-Technology-Intel-RST-RAID-Driver?v=t</a></p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GIT分支管理模型</title>
      <link href="/2016/git-branching-model/"/>
      <url>/2016/git-branching-model/</url>
      
        <content type="html"><![CDATA[<h3 id="GIT分支管理模型"><a href="#GIT分支管理模型" class="headerlink" title="GIT分支管理模型"></a>GIT分支管理模型</h3><p>link: <a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">git-branching-model</a></p><h3 id="主分支（Main-branches）"><a href="#主分支（Main-branches）" class="headerlink" title="主分支（Main branches）"></a>主分支（Main branches）</h3><p>项目两个常驻分支：</p><p><strong><code>master</code></strong> 主干分支（锁定），仅用于发布新版本，平时不能在上面干活，只做代码合并、以及打标记（<code>git tag</code>）。  理论上，每当对 <code>master</code> 分支有一个合并提交操作，我们就可以使用 Git 钩子脚本来自动构建并且发布软件到生产服务器。</p><p><strong><code>develop</code></strong>开发分支（非锁定），平时干活的地方。每当发版时，需要被合并到 <code>master</code>。对于简单的项目而言，这样的分支模型已经够用了。</p><h3 id="辅助性分支（Supporting-branches）"><a href="#辅助性分支（Supporting-branches）" class="headerlink" title="辅助性分支（Supporting branches）"></a>辅助性分支（Supporting branches）</h3><p>除了常驻分支，通常大的特性开发或生产缺陷修复还建议创建相应的临时分支。因为：</p><ol><li>在分支上开发可以让你随意尝试，进退自如，比如碰上无法正常工作的特性或补丁，可以先搁在那边，直到有时间仔细核查修复为止。</li><li>团队中如果有代码审查流程，独立的分支还可以留给审查者抽空审查的时间和改进代码的余地，并将是否合并、是否发布的权利留给审查者，为代码质量设一道门槛。</li></ol><p><em>每一类分支都有一个特定目的，如何命名每一类分支？</em></p><p>建议用相关的主题关键字进行命名，并且建议将分支名称分置于不同<strong>命名空间（前缀）</strong>下，例如：</p><table><thead><tr><th>分支</th><th>来源分支</th><th>合并分支</th><th>锁定</th><th>说明</th></tr></thead><tbody><tr><td><code>feature-*</code></td><td><code>develop</code></td><td><code>develop</code></td><td>NO</td><td>特性分支，为了开发某种特定功能而建</td></tr><tr><td><code>release-*</code></td><td><code>develop</code></td><td><code>develop</code>,<code>master</code></td><td>YES</td><td>预发布分支，为了新版本的发布做准备，一般命名为<code>release-&lt;版本号&gt;</code></td></tr><tr><td><code>hotfix-*</code></td><td><code>master</code></td><td><code>develop</code>,<code>master</code></td><td>NO</td><td>补丁分支，为了修复生产缺陷而建，一般命名为 <code>hotfix-&lt;issue 编号&gt;</code></td></tr></tbody></table><p>与主分支不同，这些辅助性分支总是有一个有限的生命期，因为他们在被合并到主分支之后，就会被移除掉。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS访问Windows共享文件夹</title>
      <link href="/2016/centos-share-windows/"/>
      <url>/2016/centos-share-windows/</url>
      
        <content type="html"><![CDATA[<p><strong>1. 在地址栏中输入下面内容:</strong><br>smb://Windows IP/Share folder name，smb为Server Message Block协议的简称，是一种IBM协议，运行在TCP/IP协议之上。</p><p>从Windows 95开始，Microsoft Windows都提供了Server和Client的SMB协议支持，Microsoft为Internet提供了SMB开源版本，及CIFS(Common Internet File System)，通用文件系统。</p><p><strong>2. 将Windows的共享文件夹挂载到本地</strong></p><p>在终端中输入命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /</span><br><span class="line">mkdir myShare</span><br><span class="line">mount -t cifs -o username=&quot;administrator&quot;,password=&quot;123456&quot; //192.168.1.1/ShareFolder /myShare</span><br></pre></td></tr></table></figure></p><p>注意命令行中的空格和逗号，空密码也可以。</p><p>此命令就是将192.168.1.1上的共享文件夹ShareFolder 挂载到本地的/mnt/MyShare文件夹，执行完，就可在MyShare里看到ShareFolder里的内容。</p><p>删除挂载用命令：</p><blockquote><p>umount /myShare</p></blockquote><p><strong>3. 开机自动挂载</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/fstab</span><br><span class="line">//192.168.1.1/ShareFolder  /myShare  cifs  defaults,username=administrator,password=123456  0  2</span><br></pre></td></tr></table></figure></p><p>保存退出</p><p><strong>4. 创建软链接</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /myShare/source /data/dist</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> centos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS详解TOP命令</title>
      <link href="/2016/centos-top/"/>
      <url>/2016/centos-top/</url>
      
        <content type="html"><![CDATA[<p>最近在docker（宿主机是centos虚拟机）里安装gitlab，发现随着时间的运行，虚拟机的内存持续走高，运行几个小时之后内存已经爆掉了，putty远程处理于假死状态。<br>这个时候就需要查看内存进程，发现有10多个ruby进程在运行，最终定位到docker容器的问题。</p><p><strong>使用到的指令：</strong></p><p><em>查看内存使用情况 </em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ free -m</span><br><span class="line">$ top //shift+m按内存占用比排序</span><br></pre></td></tr></table></figure></p><p><em>清理内存</em>（效果不是很理想，最终只能强制关闭虚拟机0_0）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># sync </span><br><span class="line"># echo 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure></p><p><strong>top命令经常用来监控linux的系统状况，比如cpu、内存的使用，下面是各个数据的含义。</strong></p><a id="more"></a><p> <img src="http://images2015.cnblogs.com/blog/19296/201610/19296-20161019104032170-185490859.png" alt></p><p><strong><em>第一行：</em></strong><br> 13:42:59 当前系统时间<br> 6 days, 9:29 系统已经运行了6天6小时29分钟（在这期间没有重启过）<br> 3 users 当前有3个用户登录系统<br> load average: 3.06,3.01, 1.79 load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。<br> load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑 CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</p><p><strong><em>第二行： Tasks 任务（进程）</em></strong><br>系统现在共有131个进程，其中处于运行中的有3个，127个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有1个。</p><p><strong><em>第三行：cpu状态</em></strong><br> 10.6% us 用户空间占用CPU的百分比。<br> 2.2% sy 内核空间占用CPU的百分比。<br> 0.0% ni 改变过优先级的进程占用CPU的百分比<br> 84.5% id 空闲CPU百分比<br> 2.5% wa IO等待占用CPU的百分比<br> 0.1% hi 硬中断（Hardware IRQ）占用CPU的百分比<br> 0.0% si 软中断（Software Interrupts）占用CPU的百分比<br>在这里CPU的使用比率和windows概念不同，如果你不理解用户空间和内核空间，需要充充电了。</p><p><strong><em>第四行：内存状态</em></strong><br> 8300124k total 物理内存总量（8GB）<br> 5979476k used 使用中的内存总量（5.7GB）<br> 2320648k free 空闲内存总量（2.2G）<br> 455544k buffers 缓存的内存量 （434M）</p><p><strong><em>第五行：swap交换分区</em></strong><br> 8193108k total 交换区总量（8GB）<br> 41568k used 使用的交换区总量（40.6M）<br> 8151540k free 空闲交换区总量（8GB）<br> 4217456k cached 缓冲的交换区总量（4GB）</p><p>这里要说明的是不能用windows的内存概念理解这些数据，如果按windows的方式此台服务器危矣：8G的内存总量只剩下530M的可用内存。Linux的内存管理有其特殊性，复杂点需要一本书来说明，这里只是简单说点和我们传统概念（windows）的不同。</p><p>第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。</p><p>如果出于习惯去计算可用内存数，这里有个近似的计算公式：第四行的free + 第四行的buffers + 第五行的cached，按这个公式此台服务器的可用内存： 2320648+455544 +4217456 = 6.6GB。</p><p>对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。</p><p>第六行是空行</p><p><strong><em>第七行以下：各进程（任务）的状态监控</em></strong><br> PID 进程id<br> USER 进程所有者<br> PR 进程优先级<br> NI nice值。负值表示高优先级，正值表示低优先级<br> VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES<br> RES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA<br> SHR 共享内存大小，单位kb<br> S 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程<br> %CPU 上次更新到现在的CPU时间占用百分比<br> %MEM 进程使用的物理内存百分比<br> TIME+ 进程使用的CPU时间总计，单位1/100秒<br> COMMAND 进程名称（命令名/命令行）</p><p><strong><em>多U多核CPU监控</em></strong><br>在top基本视图中，按键盘数字1，可监控每个逻辑CPU的状况：</p><p><img src="http://images2015.cnblogs.com/blog/19296/201610/19296-20161019104131654-1607305249.png" alt></p><p>观察视图，服务器有4个逻辑CPU，实际上是1个物理CPU。</p><p><strong><em>进程字段排序</em></strong><br>默认进入top时，各进程是按照CPU的占用量来排序的，在【top视图 01】中进程ID为3527的mysqld进程排在第一（cpu占用2%），进程ID为26955的java进程排在第二（cpu占用1%）。<br>可通过键盘指令来改变排序字段，比如想监控哪个进程占用MEM最多，我一般的使用方法如下：</p><ol><li>敲击键盘b（打开/关闭加亮效果），top的视图变化如下：</li></ol><p><img src="http://images2015.cnblogs.com/blog/19296/201610/19296-20161019104151420-958241661.png" alt></p><p>我们发现进程id为20517的top进程被加亮了，一般为运行状态（runing）的进程才被加亮，可以通过敲击y键关闭或打开运行态进程的加亮效果。</p><ol start="2"><li>敲击键盘x（打开/关闭排序列的加亮效果），top的视图变化如下：</li></ol><p><img src="http://images2015.cnblogs.com/blog/19296/201610/19296-20161019104210326-1382591838.png" alt></p><p>可以看到，top默认的排序列是%CPU。</p><ol start="3"><li>通过shift + &gt;或shift + &lt;可以向右或左改变排序列，下图是按一次shift + &gt;的效果图：</li></ol><p><img src="http://images2015.cnblogs.com/blog/19296/201610/19296-20161019104219873-2079336839.png" alt></p><p>视图现在已经按照%MEM来排序了。</p><p><strong><em>改变进程显示字段</em></strong></p><ol><li>敲击f键，top进入另一个视图，在这里可以编排基本视图中的显示字段：</li></ol><p><img src="http://images2015.cnblogs.com/blog/19296/201610/19296-20161019104229857-1090721030.png" alt></p><p>这里列出了所有可在top基本视图中显示的进程字段，有<em>并且标注为大写字母的字段是可显示的，没有</em>并且是小写字母的字段是不显示的。如果要在基本视图中显示CODE和DATA两个字段，可以通过敲击r和s键：</p><p><img src="http://images2015.cnblogs.com/blog/19296/201610/19296-20161019104301795-369946855.png" alt></p><ol start="2"><li>回车返回基本视图，可以看到多了CODE和DATA两个字段：</li></ol><p><img src="http://images2015.cnblogs.com/blog/19296/201610/19296-20161019104312592-441558226.png" alt></p><p><strong><em>top命令的补充</em></strong><br>top命令是Linux上进行系统监控的首选命令，但有时候却达不到我们的要求，top命令的监控最小单位是进程，所以看不到程序的线程数和客户连接数，通常可以ps和netstate两个命令来补充top的不足。</p><p><strong><em>监控java线程数：</em></strong><br> ps -eLf | grep java | wc -l<br>监控网络客户连接数：<br> netstat -n | grep tcp | grep 侦听端口 | wc -l<br>上面两个命令，可改动grep的参数，来达到更细致的监控要求。</p><p>在Linux系统一切都是文件的思想贯彻指导下，所有进程的运行状态都可以用文件来获取。系统根目录/proc中，每一个数字子目录的名字都是运行中的进程的PID，进入任一个进程目录，可通过其中文件或目录来观察进程的各项运行指标，例如task目录就是用来描述进程中线程的，因此也可以通过下面的方法获取某进程中运行中的线程数量（PID指的是进程ID）：</p><p>ls /proc/PID/task | wc -l<br>在linux中还有一个命令pmap，来输出进程内存的状况，可以用来分析线程堆栈：<br>pmap PID</p>]]></content>
      
      
      <categories>
          
          <category> centos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hyper-v虚拟机文件VHDX与VHD的格式转换</title>
      <link href="/2016/hyperv-vhdx-to-vhd/"/>
      <url>/2016/hyperv-vhdx-to-vhd/</url>
      
        <content type="html"><![CDATA[<p>今天遇到一个坑，我在本机(windows 10)上创建的CentOS虚拟机作为docker的宿主机，部署了gitlab等容器，准备迁移到服务器上的时候，发现始终无法导入，提示必须通过Hyper-v导出的方式。</p><p>实际并不是那么回事。</p><p>因为导入不行，我就想着新建个空的虚拟机，然后把现有虚拟文件附加进去总可以吧。</p><p>结果我错了，因为这个时候我才发现，原来Windows Server 2008不支持VHDX文件，我一下子懵逼了0_0，总不能让我再从头再来一遍吧。。。</p><p>好吧，但我相信程序猿不会如此为难程序猿的，果然在MSDN上发现了MS的虚拟文件转换命令，Windows PowerShell下执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Convert-VHD –Path c:\test\child1vhdx.vhdx –DestinationPath c:\test\child1vhd.vhd</span><br></pre></td></tr></table></figure><p>附上MSDN：<a href="https://technet.microsoft.com/library/hh848454.aspx" target="_blank" rel="noopener">https://technet.microsoft.com/library/hh848454.aspx</a></p>]]></content>
      
      
      <categories>
          
          <category> CI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hyper-v </tag>
            
            <tag> CI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS网络配置</title>
      <link href="/2016/centos-network-config/"/>
      <url>/2016/centos-network-config/</url>
      
        <content type="html"><![CDATA[<p>修改配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/sysconfig/network-scripts/ifcfg-eth0</span><br></pre></td></tr></table></figure></p><p>静态网络配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BOOTPROTO=static</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=192.168.0.109</span><br><span class="line">PREFIX=24 //子网掩码:255.255.255.0</span><br><span class="line">GATEWAY=192.168.0.1</span><br><span class="line">DNS1=192.168.0.1</span><br><span class="line">BROADCAST=192.168.0.255</span><br><span class="line">DEVICE=eth0</span><br></pre></td></tr></table></figure></p><p>然后ESC退出编辑模式</p><p>保存退出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq!</span><br></pre></td></tr></table></figure></p><p>或放弃修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q!</span><br></pre></td></tr></table></figure></p><p>重启网络服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure></p><p>查看IP地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> centos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用git svn clone迁移svn仓库</title>
      <link href="/2016/my-git-svn-clone/"/>
      <url>/2016/my-git-svn-clone/</url>
      
        <content type="html"><![CDATA[<h3 id="git-svn-clone时间估算"><a href="#git-svn-clone时间估算" class="headerlink" title="git svn clone时间估算"></a>git svn clone时间估算</h3><ul><li>处理器: Intel(R) Xeon(R) CPU E5-2620 @2.00GHz 2.00Ghz</li><li>内存：32.0 GB</li><li>操作系统: Windows Server 2008 R2 Enterprise SP1 64位</li><li>迁移总提交数：26000</li><li>迁移总用时：11Hour 40Min</li></ul><h3 id="git-svn-clone迁移svn仓库"><a href="#git-svn-clone迁移svn仓库" class="headerlink" title="git svn clone迁移svn仓库"></a>git svn clone迁移svn仓库</h3><p>clone命令可以指定很多参数，主要用到这些，你也可以使用git svn help查看完整的参数列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git svn clone https://172.16.0.241:8443/svn/projects -r 76896:HEAD --no-metadata --authors-file=svnuser.text --trunk=svnproject --branches=svnbranch yourGitProject</span><br></pre></td></tr></table></figure></p><ol><li>r指定起止版本号。</li><li>no-metadata阻止git导出SVN包含的一些无用信息。</li><li>authors-file必须指定svn帐号在git中的映射。</li><li>trunk指定导出仓库的主干项目路径。</li><li>branches指定svn的分支项目路径。</li></ol><p><strong>注意</strong>：clone命令需要管理员权限，否则会遇到下面的异常：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">couldn&apos;t truncate file .... at line 1393.</span><br></pre></td></tr></table></figure><p>你要做的就是右键使用管理员身份运行CMD，然后使用fatch继续执行导出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git svn fatch -r 76896:HEAD --authors-file=svnuser.text</span><br></pre></td></tr></table></figure></p><p>当然这并不是唯一的坑，你还有可能会遇到下边的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 [main] perl 24432 cygwin_exception::open_stackdumpfile: Dumping stack trace to perl.exe.stackdump</span><br><span class="line">fatal: malformed index info 100644 362f1c18ceed5d593eb021432545685283a93</span><br></pre></td></tr></table></figure></p><p>要解决这个问题，请打开隐藏项目找到.git/config文件，文件大概长这个样子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line">filemode = false</span><br><span class="line">bare = false</span><br><span class="line">logallrefupdates = true</span><br><span class="line">symlinks = false</span><br><span class="line">ignorecase = true</span><br><span class="line">hideDotFiles = dotGitOnly</span><br><span class="line">longpaths = true</span><br><span class="line">[svn-remote &quot;svn&quot;]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>重要的就是longpaths = true这一句，然后fatch继续。<br>接下来的就是等待，如果你的svn库比较大，像我要导出2w+的commit，会花费相当长的时间。</p><p>so, just do it！</p><p>然然然后。。。</p><p>fetch之后通过git log你会发现看不到新的log，这是因为fetch之后并不会自动将代码合并到当前master,我们查看一下所有的分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line">* master</span><br><span class="line">  remotes/origin/trunk</span><br></pre></td></tr></table></figure></p><p>可以看到有一个远程分支，这个就是SVN产生的分支，查看一下log<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log remotes/origin/trunk</span><br></pre></td></tr></table></figure></p><p>LOG中显示了SVN最新的提交日志，我们需要手动合并到master上,然后查看日志包含了最新的提交。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge remotes/origin/trunk</span><br><span class="line">git log</span><br></pre></td></tr></table></figure></p><p>到此迁移已经完成，接下来添加GIT远程地址，放心将代码push到GIT服务器吧。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> svn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET 4.5+项目迁移.NET Core的问题记录</title>
      <link href="/2016/net45-to-netcore/"/>
      <url>/2016/net45-to-netcore/</url>
      
        <content type="html"><![CDATA[<p>这几天试着把目前的开发框架迁移到新的.net core平台，中间遇到的问题在这里简单记录一下。</p><p>迁移过程遇到的最大的问题IOC容器。我目前使用的IOC容器Castle Windsor还没有.net core版本的实现，虽然core本身提供有注入功能，但我想在代码上尽量保持与.NET Framework的兼容，最后还是选择使用第三方容器Autofac，不过在容器上层做了隔离，也就是可以随时替换掉IOC。<br>关于第三方容器接管.net core的注入实现，官方文档有介绍，也可以参考autofac的实现<br><a href="https://github.com/autofac/Autofac.Extensions.DependencyInjection" target="_blank" rel="noopener">https://github.com/autofac/Autofac.Extensions.DependencyInjection</a></p><p>第二个问题是.net core没有App Domain，不能像以前那样方便的加载项目程序集，替换方法是手工扫描BIN目录，再通过AssemblyLoadContext加载到内存。不过遇到一个问题是在加载入口项目DLL的时候，会提示无法加载，目前我是通过Assembly.GetEntryAssembly()后简单粗暴的排除掉。哪位朋友知道有更好的方法，劳烦告知一下。</p><blockquote><p>其他方式:<br>var assemblies = DependencyContext.Default.RuntimeLibraries;//需要引用程序集<br>…</p></blockquote><p>第三个问题是很多Type的反射接口不存在了，可以通过Type.GetTypeInfo()获取，不过要额外引用扩展库。</p><p>第四个问题是在发布到服务器IIS之后，出现下面的异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP Error 502.5 - Process Failure</span><br><span class="line"></span><br><span class="line">Common causes of this issue:</span><br><span class="line">The application process failed to start.</span><br><span class="line">The application process started but then stopped.</span><br><span class="line">The application process started but failed to listen on the configured port.</span><br></pre></td></tr></table></figure><p>WINDOWS系统日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to start process with commandline &apos;&quot;dotnet&quot; .\Portal.dll&apos;, ErrorCode = &apos;0x80070002&apos;.</span><br></pre></td></tr></table></figure><p>首先说一下，在部署IIS的时候，需要在windows server上安装文件DotNetCore.1.0.1-WindowsHosting.exe，它会在IIS上添加一个aspnetcore module，托管net core的运行。新建站点后将应用程序池修改为无托管模式即可。就在这个地方我遇到上边的错误，页面一直提示502无法打开，端口和编译平台都没有问题。<br>网上找了很多方法试过后都没有效果，最后感觉还是hosting的问题，而且我在安排hosting文件的时候的确报过一次错，后来是用右键管理员运行安装完成的，然后到iis模块下果真没有找到aspnetcore module。<br>卸载后重装又出现了第一次的问题，安装失败。最后在stackoverflow上看到一句话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Make sure when you install the DotNetCore WindowsHosting you have access to the internet because the installer download the VS 2015 resist x64 as dependency.</span><br><span class="line"></span><br><span class="line">VS 2015 resist x64 - http://download.microsoft.com/download/8/c/b/8cb4af84-165e-4b36-978d-e867e07fc707/vc_redist.x64.exe</span><br></pre></td></tr></table></figure><p>果断下载安装后再运行WindowsHosting就没再报错了，这里还需要重启一下服务器。</p><p><a href="https://aka.ms/dotnetcore_windowshosting_1_1_0" target="_blank" rel="noopener">https://aka.ms/dotnetcore_windowshosting_1_1_0</a></p><p>手指在键盘上飞快的敲下那一串域名，点击Enter，那一刻的感觉好极了@@</p>]]></content>
      
      
      <categories>
          
          <category> dotnet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netcore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 环境变量批处理</title>
      <link href="/2015/java-config-bash/"/>
      <url>/2015/java-config-bash/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">set regpath=HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment</span><br><span class="line">set javahome=D:\Java\jdk1.7.0_40</span><br><span class="line">echo.</span><br><span class="line">echo ************************************************************</span><br><span class="line">echo *                                                          *</span><br><span class="line">echo *                   JDK 系统环境变量设置                     *</span><br><span class="line">echo *                                                          *</span><br><span class="line">echo ************************************************************</span><br><span class="line">echo.</span><br><span class="line">echo # 准备设置环境变量: JAVA_HOME=%javahome%</span><br><span class="line">echo # 注意: 如果JAVA_HOME存在,会被覆盖,此操作不可逆的,请仔细检查确认!</span><br><span class="line">echo.</span><br><span class="line">echo # 准备设置环境变量(后面有个.): classPath=%%JAVA_HOME%%\lib\tools.jar;%%JAVA_HOME%%\lib\dt.jar;.</span><br><span class="line">echo # 注意: 如果classPath存在,会被覆盖,此操作不可逆的,请仔细检查确认!</span><br><span class="line">echo.</span><br><span class="line">echo # 准备设置环境变量: PATH=%%JAVA_HOME%%\bin</span><br><span class="line">echo # 注意: PATH会追加在最前面,</span><br><span class="line">echo.</span><br><span class="line">set /P EN=请确认后按 回车键 开始设置...</span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line">echo # 新创建环境变量 JAVA_HOME=%javahome%</span><br><span class="line">setx &quot;JAVA_HOME&quot; &quot;%javahome%&quot; -M</span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line">echo # 新创建环境变量 classPath=%%JAVA_HOME%%\lib\tools.jar;%%JAVA_HOME%%%\lib\dt.jar;.</span><br><span class="line">setx &quot;classPath&quot; &quot;%%JAVA_HOME%%\lib\tools.jar;%%JAVA_HOME%%%\lib\dt.jar;.&quot; -m</span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line">echo # 新追加环境变量(追加到最前面) PATH=%%JAVA_HOME%%\bin</span><br><span class="line">for /f &quot;tokens=1,* delims=:&quot; %%a in (&apos;reg QUERY &quot;%regpath%&quot; /v &quot;path&quot;&apos;) do (</span><br><span class="line">    set &quot;L=%%a&quot;</span><br><span class="line">    set &quot;P=%%b&quot;</span><br><span class="line">)</span><br><span class="line">set &quot;Y=%L:~-1%:%P%&quot;</span><br><span class="line"></span><br><span class="line">setx path &quot;%%JAVA_HOME%%\bin;%Y%&quot; -m</span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line">echo 请按任意键退出...</span><br><span class="line">pause&gt;nul</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用FluentNHibernate出现列“ReservedWord”不属于表 ReservedWords</title>
      <link href="/2015/fluentnhibernate-reservedword/"/>
      <url>/2015/fluentnhibernate-reservedword/</url>
      
        <content type="html"><![CDATA[<p>NHibernate+FluentNHibernate+MySql 运行时黄页显示下边的异常，项目中找了半天没出现过这个列的关键字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[ArgumentException: 列“ReservedWord”不属于表 ReservedWords。]</span><br><span class="line">   System.Data.DataRow.GetDataColumn(String columnName) +5310119</span><br><span class="line">   System.Data.DataRow.get_Item(String columnName) +13</span><br><span class="line">   NHibernate.Dialect.Schema.AbstractDataBaseSchema.GetReservedWords() +170</span><br><span class="line">   NHibernate.Tool.hbm2ddl.SchemaMetadataUpdater.GetReservedWords(Dialect dialect, IConnectionHelper connectionHelper) +100</span><br><span class="line">   NHibernate.Tool.hbm2ddl.SchemaMetadataUpdater.Update(ISessionFactory sessionFactory) +78</span><br><span class="line">   NHibernate.Impl.SessionFactoryImpl..ctor(Configuration cfg, IMapping mapping, Settings settings, EventListeners listeners) +700</span><br><span class="line">   NHibernate.Cfg.Configuration.BuildSessionFactory() +104</span><br><span class="line">   FluentNHibernate.Cfg.FluentConfiguration.BuildSessionFactory() in c:\work\coding\fluentNhibernate\src\FluentNHibernate\Cfg\FluentConfiguration.cs:230</span><br><span class="line"></span><br><span class="line">[FluentConfigurationException: An invalid or incomplete configuration was used while creating a SessionFactory. Check PotentialReasons collection, and InnerException for more detail.]</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>百度到下边的类似问题：</p><p>error1.  <strong>Could not create the driver from NHibernate.Driver.MySqlDataDriver</strong></p><p>解决方法：在使用Nhibernate连接Mysql时报这个错，请把MySql.Data.dll文件手动 拷贝到xxx/工程文件目录/bin/Debug下 就可以解决这个问题了！</p><p>error2. <strong>列“ReservedWord”不属于表 ReservedWords</strong><br>解决方法：在hibernate.cfg.xml配置文件中加入<property name="hbm2ddl.keywords">none</property></p><p>最后在stackoverflow上找到对应的用FluentNHibernate配置的方法（最后一行的配置）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Configuration.DefaultNameOrConnectionString = ConfigurationManager.ConnectionStrings[&quot;Default&quot;].ConnectionString;</span><br><span class="line">Configuration.Modules.AbpNHibernate().FluentConfiguration</span><br><span class="line">             .Database(MySQLConfiguration.Standard.ConnectionString(Configuration.DefaultNameOrConnectionString))</span><br><span class="line">             .Mappings(m =&gt; m.FluentMappings.AddFromAssembly(Assembly.GetExecutingAssembly()));</span><br><span class="line">             .ExposeConfiguration(c =&gt; c.Properties.Add(&quot;hbm2ddl.keywords&quot;, &quot;none&quot;));</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> dotnet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nhibernate </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
